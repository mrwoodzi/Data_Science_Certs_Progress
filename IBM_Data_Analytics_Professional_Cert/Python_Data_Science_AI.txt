You can slice a variable that has a nested lists or tuples with [][]
List 
    syntax to clone a variable
        variable = OtherVariable[:]
.split() - can use delimiter for the split 
.index() - to find the index of a known element in list, tuple, ....
sorted() - sorted(SomeList) -this will also turn a tuple into a list

Dictionary
    You can access elements in a dictionary if you know the key by Dict['known_key']

    del(Dict['known_key'])
    'known_key' in Dict  # finds if the 'known_key' is in the dictionary
        True or False response

# Append value with key into dictionary

release_year_dict['Graduation'] = '2007'
release_year_dict

Sets
    -unordered
    -sets donot have element positions
    -only 1 element of a set can exist, meaning no duplicates
    -{} curly brackets
    -convert list to set 
    -set(my_list)
    - to add variable.add(thing_to_add)
    - to remove variable.remove(thing_to_add)
    - 'item' in variable_set
        -returns bool
    - & to find the intersection of 2 sets 
        variable_intersection = variable1&variable2
    - finding a subset 
        variable.issubset(otherVariable)
            -returns a bool
    - fiinding the Difference
        -variable.difference(variable2)
    - Union 
        variable.union(OtherVariable)
    - SuperSet 
        set(variable).issuperset(OtherVariable)


Conditions and Branching
    Comparison Operators return a boolean
        Or
            false, false = false
            false, true = true
            true, false = true
            true, true = true
        and
            false, false = false
            false, true = false
            true, false = false
            true, true = true 
        not
            false, true
            false, true 

    Range:
        -think of it as an unordered list
    For:
        -enables you to execute a code block multiple times
        - exx if you want to print out every element in a list

    Loops:
        enumerate - iterate through a list and provides the index of each element
            for iterator,variable in enumerate(variable):
        Also
            for i,x in enumerate(['A','B','C']):
                print(i,x)

    While Loops:
        variable = ['foo', 'bar', 'stuff', 'foo']
        new_variable = []
        iterator = 0
        while(variable[iterator]=='foo'):  # will exit on slice 1 cause it's bar not foo
            new_variable.append(variable[iterator])
            iterator = iterator + 1

# While Loop Example

dates = [1982, 1980, 1973, 2000]
i = 0
year = dates[0]

while(year != 1973):    
    print(year)
    i = i + 1
    year = dates[i]
    
print("It took ", i ,"repetitions to get out of loop.")

Functions:

    printing a stand alone function will not make it return function()
    calling a function by using print print(function())
        will on return what is after return
    
    def print_stuff(stuff):
        for i,s in enumerate(stuff):  # this prints an index as i and s as whatever stuff you pass
            print('album', i, 'Rating is', s)
        
        album_ratings = [10,8.5,9.5]
        printStuff(album_ratings)

        album 0 Rating is 10

    SCOPE:
        -scope of a variable is the part of the program where that variable is accessible.
        -Variables that are defined outside of any function are said to be within the global 
            scope, meaning they can be accessed anywhere after they are defined

        Global Variables -  Variables that are defined outside of any function are said to be 
            within the global scope, meaning they can be accessed anywhere after they are defined

        Local Variables - are variables inside the function
    *****If local variable is in function Python will automatically go outside 
            We can assign a global variable by using word global inside a function 
    
    Exception Handling:
        try:
            pass
        except IOErrot:
            print("Print something useful here.") 
        else: # this would be a basic catch all 
            print("Something went wrong.")
        finally:
            print("C
            ode to execute at the end of the try except no matter what.")

        You can have multiple excepts with **kwargs

    Objects and Classes:
        Types of built in classes 
            int, float, str, list, dict, bool and each is an object
                Every object has the following: a type, internal representation,
                 a set of functions called methods to interact with the data. 

    Class to Object to Data Attribute to Method Attribute
    Instance -instances
     of an object 
    dir() gives you data and method attributes

    variable gets passed in circle class and circle class instantiates the variable


Opening Files:
    .open('selected_file, 'mode') # mode r for reading(.txt), w writing, a appending #file is a object
    selected_file.name # gives the name of file

    Use with open('selected_file', 'mode') as file1: # better and will automatically close file
        file_stuff = file1.read('optional number of characters to read here')
        print(file_stuff)
    print(file1.closed)
    print(file_stuff)
    .readlines() # outputs lines of file as a list 
        # if you use this again in exact same manner it will print the 2nd line of file 

# Iterate through the lines

with open(example1,"r") as file1:
        i = 0;
        for line in file1:
            print("Iteration", str(i), ": ", line)
            i = i + 1

# Read all lines and save as a list

with open(example1, "r") as file1:
    FileasList = file1.readlines()
    

