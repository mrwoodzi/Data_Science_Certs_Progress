You can slice a variable that has a nested lists or tuples with [][]
List 
    syntax to clone a variable
        variable = OtherVariable[:]
.split() - can use delimiter for the split 
.index() - to find the index of a known element in list, tuple, ....
sorted() - sorted(SomeList) -this will also turn a tuple into a list

Dictionary
    You can access elements in a dictionary if you know the key by Dict['known_key']

    del(Dict['known_key'])
    'known_key' in Dict  # finds if the 'known_key' is in the dictionary
        True or False response

# Append value with key into dictionary

release_year_dict['Graduation'] = '2007'
release_year_dict

Sets
    -unordered
    -sets donot have element positions
    -only 1 element of a set can exist, meaning no duplicates
    -{} curly brackets
    -convert list to set 
    -set(my_list)
    - to add variable.add(thing_to_add)
    - to remove variable.remove(thing_to_add)
    - 'item' in variable_set
        -returns bool
    - & to find the intersection of 2 sets 
        variable_intersection = variable1&variable2
    - finding a subset 
        variable.issubset(otherVariable)
            -returns a bool
    - fiinding the Difference
        -variable.difference(variable2)
    - Union 
        variable.union(OtherVariable)
    - SuperSet 
        set(variable).issuperset(OtherVariable)


Conditions and Branching
    Comparison Operators return a boolean
        Or
            false, false = false
            false, true = true
            true, false = true
            true, true = true
        and
            false, false = false
            false, true = false
            true, false = false
            true, true = true 
        not
            false, true
            false, true 

    Range:
        -think of it as an unordered list
    For:
        -enables you to execute a code block multiple times
        - exx if you want to print out every element in a list

    Loops:
        enumerate - iterate through a list and provides the index of each element
            for iterator,variable in enumerate(variable):
        Also
            for i,x in enumerate(['A','B','C']):
                print(i,x)

    While Loops:
        variable = ['foo', 'bar', 'stuff', 'foo']
        new_variable = []
        iterator = 0
        while(variable[iterator]=='foo'):  # will exit on slice 1 cause it's bar not foo
            new_variable.append(variable[iterator])
            iterator = iterator + 1

# While Loop Example

dates = [1982, 1980, 1973, 2000]
i = 0
year = dates[0]

while(year != 1973):    
    print(year)
    i = i + 1
    year = dates[i]
    
print("It took ", i ,"repetitions to get out of loop.")

Functions:

    printing a stand alone function will not make it return function()
    calling a function by using print print(function())
        will on return what is after return
    
    def print_stuff(stuff):
        for i,s in enumerate(stuff):  # this prints an index as i and s as whatever stuff you pass
            print('album', i, 'Rating is', s)
        
        album_ratings = [10,8.5,9.5]
        printStuff(album_ratings)

        album 0 Rating is 10

    SCOPE:
        -scope of a variable is the part of the program where that variable is accessible.
        -Variables that are defined outside of any function are said to be within the global 
            scope, meaning they can be accessed anywhere after they are defined

        Global Variables -  Variables that are defined outside of any function are said to be 
            within the global scope, meaning they can be accessed anywhere after they are defined

        Local Variables - are variables inside the function
    *****If local variable is in function Python will automatically go outside 
            We can assign a global variable by using word global inside a function 
    
    Exception Handling:
        try:
            pass
        except IOErrot:
            print("Print something useful here.") 
        else: # this would be a basic catch all 
            print("Something went wrong.")
        finally:
            print("C
            ode to execute at the end of the try except no matter what.")

        You can have multiple excepts with **kwargs

    Objects and Classes:
        Types of built in classes 
            int, float, str, list, dict, bool and each is an object
                Every object has the following: a type, internal representation,
                 a set of functions called methods to interact with the data. 

    Class to Object to Data Attribute to Method Attribute
    Instance -instances
     of an object 
    dir() gives you data and method attributes

    variable gets passed in circle class and circle class instantiates the variable


Opening Files:
    .open('selected_file, 'mode') # mode r for reading(.txt), w writing, a appending #file is a object
    selected_file.name # gives the name of file

    Use with open('selected_file', 'mode') as file1: # better and will automatically close file
        file_stuff = file1.read('optional number of characters to read here')
        print(file_stuff)
    print(file1.closed)
    print(file_stuff)
    .readlines() # outputs lines of file as a list 
        # if you use this again in exact same manner it will print the 2nd line of file 

# Iterate through the lines

with open(example1,"r") as file1:
        i = 0;
        for line in file1:
            print("Iteration", str(i), ": ", line)
            i = i + 1

# Read all lines and save as a list

with open(example1, "r") as file1:
    FileasList = file1.readlines()

# Write line to file
exmp2 = 'Example2.txt'
with open(exmp2, 'w') as writefile:
    writefile.write("This is line A")

# Read file
with open(exmp2, 'r') as testwritefile:
    print(testwritefile.read())

# Check whether write to file
with open(exmp2, 'r') as testwritefile:
    print(testwritefile.read())

# Sample list of text
Lines = ["This is line A\n", "This is line B\n", "This is line C\n"]
Lines

# Write the strings in the list to text file
with open('Example2.txt', 'w') as writefile:
    for line in Lines:
        print(line)
        writefile.write(line)

# Verify if writing to file is successfully executed
with open('Example2.txt', 'r') as testwritefile:
    print(testwritefile.read())

# However, note that setting the mode to w overwrites all the existing data in the file.
with open('Example2.txt', 'w') as writefile:
    writefile.write("Overwrite\n")
with open('Example2.txt', 'r') as testwritefile:
    print(testwritefile.read())
    
# Write a new line to text file 'a' is to appenda line
with open('Example2.txt', 'a') as testwritefile:
    testwritefile.write("This is line C\n")
    testwritefile.write("This is line D\n")
    testwritefile.write("This is line E\n")

It's fairly ineffecient to open the file in a or w and then reopening it in r to read any lines. 
Luckily we can access the file in the following modes:

r+ : Reading and writing. Cannot truncate the file.
w+ : Writing and reading. Truncates the file.
a+ : Appending and Reading. Creates a new file, if none exists. You dont have to dwell on the specifics 
of each mode for this lab.

******************************************************************************
Most of the file methods we've looked at work in a certain location in the file. .write()  writes at a 
certain location in the file. .read() reads at a certain location in the file and so on. You can think 
of this as moving your pointer around in the notepad to make changes at specific location.
####################################################################################
Opening the file in w is akin to opening the .txt file, moving your cursor to the beginning of the text file, 
writing new text and deleting everything that follows. Whereas opening the file in a is similiar to opening the 
.txt file, moving your cursor to the very end and then adding the new pieces of text.
It is often very useful to know where the 'cursor' is in a file and be able to control it. The following methods 
allow us to do precisely this -

.tell() - returns the current position in bytes
.seek(offset,from) - changes the position by 'offset' bytes with respect to 'from'. From can take the value of 
    0,1,2 corresponding to beginning, relative to current position and end


with open('Example2.txt', 'a+') as testwritefile:
    print("Initial Location: {}".format(testwritefile.tell()))
    
    data = testwritefile.read()
    if (not data):  #empty strings return false in python
            print('Read nothing') 
    else: 
            print(testwritefile.read())
            
    testwritefile.seek(0,0) # move 0 bytes from beginning.
    
    print("\nNew Location : {}".format(testwritefile.tell()))
    data = testwritefile.read()
    if (not data): 
            print('Read nothing') 
    else: 
            print(data)
    
    print("Location after read: {}".format(testwritefile.tell()) )

Initial Location: 115
Read nothing

New Location : 0
Overwrite
This is line C
This is line D
This is line E
This is line C
This is line D
This is line E
This is line E

Location after read: 115

Finally, a note on the difference between w+ and r+. Both of these modes allow access to read and write methods, 
however, opening a file in w+ overwrites it and deletes all pre-existing data.
To work with a file on existing data, use r+ and a+. While using r+, it can be useful to add a .truncate() method 
at the end of your data. This will reduce the file to your data and delete everything that follows.
In the following code block, Run the code as it is first and then run it with the .truncate().

with open('Example2.txt', 'r+') as testwritefile:
    data = testwritefile.readlines()
    testwritefile.seek(0,0) #write at beginning of file
   
    testwritefile.write("Line 1" + "\n")
    testwritefile.write("Line 2" + "\n")
    testwritefile.write("Line 3" + "\n")
    testwritefile.write("finished\n")
    #Uncomment the line below
    #testwritefile.truncate()
    testwritefile.seek(0,0)
    print(testwritefile.read())

Line 1
Line 2
Line 3
finished
is line D
This is line E
This is line C
This is line D
This is line E
This is line E

# Copy file to another
with open('Example2.txt','r') as readfile:
    with open('Example3.txt','w') as writefile:
          for line in readfile:
                writefile.write(line)

# Verify if the copy is successfully executed
with open('Example3.txt','r') as testwritefile:
    print(testwritefile.read())