Scripting In Bash:

Run
    #!/bin/bash # also known as a shebang
        -put this at top of scripting file so you can just run the file like
            .\filname.sh
    sh 
        running in the shell
    bash 
        running in bash


psql
    -you can use it to turn a single command and exit 
    -BUT this needs to be in file you want to run 
        PSQL="psql -X --username=freecodecamp --dbname=students --no-align --tuples-only -c"
    -query your database like this  
        $($PSQL "<query_here>")  

help
    let # view of the potential operators in the terminal 
    man <command> gives information about a command 
        # this works sometimes other times help will work 



echo     
    echo -e "\n  ~~ Countdown Timer \n"
        -don't forget the script -e in the file 

print   
    cat <filename>
    echo $variable

List 
    ls 
    ls -l 
        this gives you long form 
    ls /
        lists what's in the root of the file system
    ls /bin 
        view what's in bin 

Passing Arguements
    $* # from the terminal it will print all arguements passed to it 
            from the terminal 
    echo $? # to view exit status of last command 
    echo $the_you_type_what_you_want_to_print

Permissions
    chmod +x filename.sh 
        -this gives everyone permission to use the file 
            - the x means everyone can use it 

IFS 
    Internal Field Operator 
        -variable used to determine word boundaries
        -defaults to spaces, tabs and new lines 

While loop  
    cat filename.csv | while IFS="," read THING OTHER_THING
    do 
        <statements>
    done
    # each new line will be read into variables THING and OTHER_THING
    # It's looping, but the THING variable is only being set to the first word
    # There's a default IFS variable in bash. IFS stands for "Internal 
        Field Separator". View it with declare -p IFS
    

    $
        Variable Expansion: 
            When followed by a variable name (e.g., $variable), it represents the value of that variable.

        Command Substitution: 
            When enclosed in backticks (`command`) or within $(command), it indicates that the enclosed 
                command should be executed, and the output of that command should be substituted.

        Special Variables: 
            There are special variables in Bash that are preceded by a dollar sign, such as "$@", "$#", "$?", etc., 
                each with its own specific meaning.

        Math Expansion: 
            In the context of arithmetic expansion, $((expression)), it denotes mathematical operations.

        Shell Process ID: 
            $ followed by $$ represents the process ID of the current shell.

        Shell Script Positional Parameters: 
            $1, $2, etc., represent the positional parameters passed to a shell script or a function.

        Wildcard Expansion: 
            $* and $? are used in wildcard expansion, where they represent all positional parameters and the exit 
                status of the last executed command, respectively.

User Input
    read variable_name_user_input_will_be _stored

All Variables in Shell/Bash
    declare -P
        # declare can also be used to create variables 
        # will also show variable user makes 
    var=$(( var - int )) # setting variable with calculation in terminal 

Where is Interpreter 
    which bash 

Permissions
    chmod   -x  <filename>
    [[ -x countdown.sh ]]; echo $?
        -this will check permissions 

Syntax 

QUESTION1="What's your name?"
echo $QUESTION1
read NAME


Boolean 
    help [[
        -type this in the terminal to see the boolean help 
    -eq (equal), -ne (not equal), 
    -lt (less than), 
    -le (less than or equal), 
    -gt (greater than), 
    -ge (greater than or equal)

     Returns a status of 0 or 1 depending on the evaluation of the conditional
    expression EXPRESSION.  Expressions are composed of the same primaries used
    by the `test' builtin, and may be combined using the following operators:
    
      ( EXPRESSION )    Returns the value of EXPRESSION
      ! EXPRESSION              True if EXPRESSION is false; else false
      EXPR1 && EXPR2    True if both EXPR1 and EXPR2 are true; else false
      EXPR1 || EXPR2    True if either EXPR1 or EXPR2 is true; else false
    
    When the `==' and `!=' operators are used, the string to the right of
    the operator is used as a pattern and pattern matching is performed.
    When the `=~' operator is used, the string to the right of the operator
    is matched as a regular expression.
    
    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to
    determine the expression's value.
    
    Exit Status:
        echo $?
            -type in terminal to see the previous exit status
            - [[ 4 -le 5 ]]; echo $?
                -this will print the exit status after you hit enter 
        0 or 1 depending on value of EXPRESSION.
            0 is True but better thought of as zero erros
            Anything but 0 means there was an error with the command

    help    
        help test   
            - type that in the terminal 
            -utilizes the built-in commands
        help let 
            boolean/comparison help menu 
        help [[ expression ]]
            -to see list of expressions 


    environment variables 
        printenv - in terminal
        declare -p 
            -view all variables in the shell 


    Comment Out:

                    : '   # make sure there is a space between : '
                    put your comment here 
                    '
                    OR 
                    #comment

(( this uses python boolean))

[[ this uses the -le, -ge]]

if statements 
    if (( CONDITION )) these use no $ and <= >= < >    
    then
        STATEMENTS
    elif [[ CONDITION ]] these use $ and -le -gt -ge
    then
        STATEMENTS
    fi

for loops
    -2 different types  
        -help menu shows the basic format 

until loop  
    until [[ $QUESTION == test? ]]
    do
        GET_FORTUNE
    done

QUERYING inside a loop  
    variable=$($PSQL "<write query here and it spits out the result as the variable>")
        -make sure to put an variables inside the query in single quotes 

sleep 

while
    while [[ CONDITION ]]
    do
        STATEMENTS
    done

Random Number Generator 
    use $RANDOM variable 
    modulus operator to put RANDOM in the number range you want 
    EX.
        $RANDOM%75

Variables in the Terminal 
    Note that you don't need to prepend variable swith $ inside these parenthesis
        (( I += 10 ))
        double parenthesis with a $ are how you can assign a variable to some calculation
        (( ... )) will perform a calculation or operation and output nothing. 
        $(( ... )) will replace the calculation with the result of it
    declare -P  
        view variables in terminal 
    declare 
        can be used to create variables 

Arrays
    creating arrays in the terminal
    ARR=(<"your stuff" "more stuff")
    In terminal 
        echo $ARR{[1]}
            -to print the second item in an array 
        echo ${ARR[$]} or replace the $ with a @
            to print whole array 
        declare -p ARR
            for a different type of view of the whole variable 

Pattern recognision 
    =~
        to test if 'el' is in 'hello'
            would return a 0 
        syntax in terminal 
            [[ 'hello world' =~ 'lo wor' ]]; echo $?

            to see if it starts with h 
                [[ 'hello world' =~ ^h ]]; echo $?
            to see if has at least one character after it and ends with a d
                [[ 'hello world' =~ ^h.+d$ ]]; echo $?
            check if something ends with <something>
                [[ $VAR =~ \<something>$ ]]; echo $?

Standard Output(stout), Standard Error(sterr) 
    < > 
    > redirect or writing 
        echo hello bash > stdout.txt 
            # > will overwrite hello bash in file with nothing else 
            # > will overwrite everything in file so be careful 
            # it also created the file stdout.txt 
            > stdout.txt 
                # this redirects nothing to the file so it erases everything in it 
            echo "~~ kitty_ipsum_1.txt info ~~" > kitty_info.txt
                # this writes to the .txt file what is in quotes 
    echo hello bash >> stdout.txt 
        # will append(add) an extra hello bash to the file 
    2> # stderr - redirect standard error 
        # can used to redirect Standard Error(stderr)
        # echo Michael | ./script.sh 2> stderr.txt 1> stdout.txt
    1> stdout redirect 
        # can be used to redirect Standard Output(stdout)
        # echo Michael | ./script.sh 2> stderr.txt 1> stdout.txt
    cat 
        # cat will print the contents of a file or input to stdout
        # cat can take a filename as an argument
        echo NAME | cat
            # will print NAME, not the variable 
        cat < name.txt
            # will print the contents of the name.txt file 
    
Standard In(stdin)
    < (stdin)
        <command> < <filename_for_stdin>
        ./script.sh < name.txt
            # name.txt is set as the input for NAME in ./script.sh
        -also called 'pipe'
        -creates a subshell or subprocess
            -subshell/subprocess is another instance of the shell
        <command_1> | <command_2>
            echo NAME | read NAME
        echo Michael | ./script.sh
            # this input Michael for read NAME variable 
    >> append 
        cat filename |wc flag >> filename
            cat kitty_ipsum_1.txt | wc -l >> kitty_info.txt cat

Combining stdout, stderr, stdin 

        ./script.sh < name.txt 2> stderr.txt > stdout.txt

Commands: 
    man <insert_command_you_dont_understand>

    wc 
        -Print  newline, word, and byte counts for each FILE
    grep 
        grep 'thing to search' filename
        --color 
            -adds color to the 'thing to search' when it is found 
        -c 
            -give a count 
        -n 
            -tells you at what line 'thing to search' happens
            -Prefix each line of output with the 1-based line number within its input file.
        -o 
            -only outputs the string you are looking for, NOT the whole line and the string 
            -prints all the matching strings
            -Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line.
        -sed 
            -used to replace basic text transformations on an input streamq

            -replacing text that might work 
            -sed 's/<pattern_to_replace>/<text_to_replace_it_with>/' <filename>.
            -By default, it won't replace the text in the file. It will output it to stdout 
                -will output something different in terminal but not change it in the file 
            -sed with a flag   
                -sed 's/<pattern>/<replacement>/<regex_flags>' <filename>
                    -sed 's/freecodecamp/f233C0d3C@mp/i' name.txt
                    -g for global 
                        -replace all instances of a matched pattern 
                    -i 
                        -ignore the case of a pattern
                Example: 
                    -sed 's/freecodecamp/f233C0d3C@mp/i' < name.txt
                        -actually outputs f233C0d3C@mp into terminal with < 
                    grep -n 'meow[a-z]*' kitty_ipsum_1.txt | sed -E 's/([0-9]+).*/\1/'
                        -this outputs the line numbers that have 'meow' in them 
    
        
        Examples grep:
            -grep -o 'meow[a-z]*' kitty_ipsum_1.txt | wc -l
                -count of how many times those words appear
            -grep -o 'meow[a-z]*' kitty_ipsum_2.txt | wc -l >> kitty_info.txt
                counts the number of times 'meow' occurs in any word in file then appends it to the kitty_info file
            -grep -n 'meow[a-z]*' kitty_ipsum_2.txt | sed -E 's/([0-9]+).*/\1/' >> kitty_info.txt
                appends the line numbers that words with 'meow' occur on in file to kitty_info
            -grep -o 'cat[a-z]*' kitty_ipsum_2.txt | wc -l >> kitty_info.txt
                gives count of how many times 'cat' occurs in a word

Commands that do the essentially the same thing 

    wc < kitty_ipsum_1.txt
    cat kitty_ipsum_1.txt | wc

    wc -m < kitty_ipsum_1.txt >> kitty_info.txt
    cat kitty_ipsum_1.txt | wc -m >> kitty_info.txt

    sed 's/freecodecamp/f233C0d3C@mp/i' < name.txt
    cat name.txt | sed 's/freecodecamp/f233C0d3C@mp/i'
