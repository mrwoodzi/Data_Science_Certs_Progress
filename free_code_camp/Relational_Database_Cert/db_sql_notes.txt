Installing PostgreSQL:
    I have been working on this for a couple hours today and I am having some kind
        of an issue with my password/connecting to port 5432(standard port used for PostgreSQL)
        
    Checking Services in windows
        Starting PostgreSQL Server in Windows GUI
            win + r
            type -> services.msc
            search -> find the postgreSQL .exe make sure it is running/started
        Starting postgreSQL in Powershell from free_code_camp folder:
            & "C:\Program Files\PostgreSQL\16\bin\pg_ctl.exe" start -D "C:\Program Files\PostgreSQL\16\data"

        Starting PostgreSQL in Git Bash 
            Start:
                ./pg_ctl.exe start -D "C:/Program Files/PostgreSQL/16/data"
            Check Start:
                ./pg_ctl.exe status -D "C:/Program Files/PostgreSQL/16/data"


    Logging in Via Powershell:
        C:\Program Files\PostgreSQL\16\bin> .\psql.exe -U postgres

        Logging in from free_code_camp
        & "C:\Program Files\PostgreSQL\16\bin\psql.exe" -U postgres
    Logging in via dbeaver:
        user: postgres 
        pass: ****

Bash Tutorial:
    pink - images
        .jpg
        .png 
        .svg 
    blue - folders
    white - files 
        .font
        .css 
        .js 
        .txt 
    make sure you are in the freeCodeCamp folder 
    Delete Database 
        DROP DATABASE [IF EXISTS] dbname;
    echo 
        printing in terminal 
        echo text >> filename (You need the arrows)
            printing to a file 
            appends to the file is better way to think about it 
    more 
        more filename
        prints contents of file 
    Adding a flag:
        ls the_flag
        long list format =  ls -l (lower case L)
    Look inside a file 
        more command
    Go back 2 folders cd ../..
    echo 
        print command 
    touch filename  
        creates a new file
        touch filename
        touch dir/dir/filename 
    .gitignore was hidden when we created it
    --help
        command_you_want_help_with --help 
    cp 
        copy a file 
        cp <file> <destination>
    rm 
        remove file from current directory 
        rm filename 
    mv 
        rename filename or move something 
        mv <filename> <new_filename> 
        mv <file> <destination>
        mv <file> <folder/folder>
    find 
        allows you to view file tree in current folder 
        find
            You can see everything in this website folder and its descendant folders
        find <folder_name>
            specific folder 
        find -name <filename> or <folder>
            finding a specific file in folder or find a folder 
        find dir/dir/dir
    mkdir 
        mk directoryName
        mkdir client/<new_folder_name>
            making folder inside folder 
    -r, -R, --recursive   remove directories and their contents recursively or copy 
        -removing dir/folders with their contents 
        cp -r dirname newdirname 
            -does a copy paste and rename 


    Your virtual machine comes with PostgreSQL installed. You will use the Psql terminal application to interact 
        with it. Log in by typing psql --username=freecodecamp --dbname=postgres into the terminal and pressing enter.
        psql --username=freecodecamp --dbname=postgres
base  
            \c database
        DATA types  
            int 
            varchar(give it a numeric maximum allowable length)
                -stands for character varying 
            bigint 

        -TRUNCATE
            -delete everything in database   
                -TRUNCATE database_name; #that's all you need to do 
            -   -if foreign keys are connecting tables you need to add those tables to be deleted as well 
                -TRUNCATE database_name, databasename, database_name;  
                -**this will not delete the column names just the row and their data 
   
        list
            \list 
            \d table_name
                - displays tables in database you are in
        connect 
            \c database_name
            think about as moving into a folder/dir 
        tables 
            \d 
            to view tables in current database 
            viewing more details of table
                \d table_name
        Creating Table 
            create table table_name();
            CREATE TABLE table_name(column_names . . .)
            CREATE TABLE table_name(column_name DATATYPE CONSTRAINTS);
        ADD COLUMN 
            ALTER TABLE table_name ADD COLUMN column_name DATATYPE;
            ALTER TABLE table_name ADD COLUMN column_name VARCHAR(40) NOT NULL UNIQUE;
        ALTER COLUMN    
            ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL;
            ALTER TABLE table_name ALTER COLUMN column_name VARCHAR(40) NOT NULL UNIQUE;
            -Adding a foreign key to an existing column
                ALTER TABLE <table_name> ADD FOREIGN KEY(<column_name>) REFERENCES <referenced_table_name>(<referenced_column_name>);
        DROP/REMOVE COLUMN 
            ALTER TABLE table_name DROP COLUMN column_name;
        RENAME COLUMN 
            ALTER TABLE table_name RENAME COLUMN column_name TO new_name;
        WHERE 
            WHERE to view data 
                SELECT columns FROM table_name WHERE condition;
        Querying Data 
            SELECT * FROM table_name; # star selects all columns 

            Selecting specific rows
                SELECT columns FROM table_name WHERE condition;
                mario_database=> SELECT character_id, name FROM characters WHERE name='Toad';

        INSERT ROW/ADD ROW 
            insert into table_name(column1, column2) values(int, str);
                INSERT MULTIPLE 
                    INSERT INTO table_name(column_1, column_2) VALUES(value_1, value_2), (value_1, value_2);
        DELETE
            delete from table_name where column_name='Luigi';
             - you don't have to use DELETE to change a VALUE you can use 
                UPDATE table_name SET column_name=new_value WHERE condition;
        ALTER TABLE <table_name> ADD FOREIGN KEY(<column_name>) REFERENCES <referenced_table_name>(<referenced_column_name>);
            alter table second_table drop username; # column names don't have to be in quotes
            changing primary key 
                ALTER TABLE table_name DROP CONSTRAINT constraint_name;
                    Try using ALTER TABLE characters DROP CONSTRAINT characters_pkey; (constraint name is found select * from TABLE_NAME)
        Foreign Key 
                    Try using ALTER TABLE characters DROP CONSTRAINT characters_pkey; (constraint name is found select * from TABLE_NAME)
        UNIQUE 
                ALTER TABLE table_name ADD UNIQUE(column_name);
        ALTER COLUMN 
                ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL;


        ORDER BY 
            SELECT * FROM table ORDER BY column_name/index; 
                -this will order your whole table by the column you chose 
        DROP    
            drop table table_name; 
            ALTER TABLE table_name DROP CONSTRAINT constraint_name;
        ALTER DATABASE/RENAMING 
            -renaming 
                ALTER DATABASE database_name RENAME TO new_database_name;
            -deleting database  
                DROP DATABASE database_name;
        TYPE 
            - ALERT TABLE table_name ADD COLUMN column_name type_name;

            -SERIAL 
                -column an INT with a NOT NULL constraint, and automatically increment 
                    the integer when a new row is added
            -VARCHAR*(char_length)
                -*****************************************************************
                -make sure it is in single quotes ''
            -INT 
            -DATE 
            -NUMERIC(4, 1)
                 has up to four digits and one of them has to be to the right of the decimal.
            -NOT NULL   
                this can be add to a row that is already of type INT 
                ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL;
        UPDATE/CHANGE ROW   
            -UPDATE table_name SET column_name='new_value__for_cell' WHERE different_column_name='index_name' 
                -UPDATE characters SET favorite_color='Orange' WHERE name='Daisy'
                ### index_name doesn't have to be an actual index just something sharing the row with the new_value__for_cell
                
        PRIMARY KEY 
            COMPOSITE PRIMARY KEY 
                -used this in junction table in mario_database
                ALTER TABLE table_name ADD PRIMARY KEY(column1, column2);
                ALTER TABLE <table_name> ADD PRIMARY KEY(<column_name>, <column_name>);
            ALTER TABLE table_name ADD PRIMARY KEY(column_name);
                Deleting Primary Key or Altering Primary Key 
                    ALTER TABLE table_name DROP CONSTRAINT constraint_name; (constraint name is found select * from TABLE_NAME)
                        ALTER TABLE more_info ADD COLUMN character_id INT REFERENCES characters(character_id);

        Foreign Key:
            ALTER TABLE table_name ADD COLUMN column_name DATATYPE REFERENCES referenced_table_name(referenced_column_name);
                adding UNIQUE TO a foreign key 
                    ALTER TABLE more_info ADD UNIQUE(character_id);
        JOIN
            FULL JOIN 
                - "One to One" relationship 
                SELECT columns FROM table_1 FULL JOIN table_2 ON table_1.primary_key_column = table_2.foreign_key_column;
                SELECT * FROM characters FULL JOIN more_info ON characters.character_id = more_info.character_id;
                -'One to Many" 
                    characters have more than one row because they have many sound
            FULL JOIN Mulitiple tables 
                SELECT columns FROM junction_table
                FULL JOIN table_1 ON junction_table.foreign_key_column = table_1.primary_key_column
                FULL JOIN table_2 ON junction_table.foreign_key_column = table_2.primary_key_column;    
                    SELECT * FROM character_actions 
                        FULL JOIN characters ON character_actions.character_id = characters.character_id 
                        FULL JOIN actions ON character_actions.action_id = actions.action_id;


    JUNCTION TABLE 
        connets other tables together 
        "Many to Many" Relationship     
        -many of the characters can perform many actions. 
        -usually use a junction table to link two tables together, forming two 'one-to-many' relationships

    COMPOSITE PRIMARY KEY 
        -used in mario_database junction table character_actions
        ALTER TABLE table_name ADD PRIMARY KEY(column1, column2);        
        This table will have multiple rows with the same character_id, and multiple rows the same action_id. So neither of them are unique.
            But you will never have the same character_id and action_id in a single row. So the two columns together can be used to uniquely identify 
            each row. View the details of the character_actions table to see your composite key. 


Searching/retriving:
        WHERE AND OR: 
            use LIKE to find patterns in text like this: WHERE <column> LIKE '<pattern>'. An underscore (_) in a pattern 
                will return rows that have any character in that spot. View the rows in this table with a course name 
                that matches the pattern '_lgorithms'.
            -WHERE IS NULL 
        LIKE
            '_'
                finds anything '_afterthis'
            '%'
                'thing%' finds anything with the 'thing' before '%'
                or '%thing' finds anything with the 'thing' after '%'

                finding spaces  
                     . . . '% %';
                finding second letter of a name 
                    . . . '_e%';
                
        ILIKE
            -will ignore the case sensitivity of a string 
             . .  .'%a%';

        NOT ILIKE   
            -will ignore the case sensitivity of a string
            . . . '%a%';

        Combining LIKE, NOT ILIKE
            SELECT * FROM courses WHERE course NOT ILIKE '<pattern>' AND course LIKE <pattern> ;

        IS NULL 
            WHERE <column> IS NULL;

        ORDER BY
            -automatically sorts by ascending(ASC)
            -descending(DESC)
            -SELECT * FROM <table> ORDER BY <column> DESC;

        LIMIT 
            -SELECT * FROM <table> ORDER BY <column> DESC LIMIT 10; # or whatever number you want
            The keywords you want are SELECT, FROM, WHERE, IS NOT NULL, ORDER BY, and LIMIT, in that order
            -SELECT * FROM students WHERE gpa IS NOT NULL ORDER BY gpa DESC, first_name LIMIT 10;

Sorting, Stats: 
    MIN 
    MAX 
    AVG 
    CEIL 
        -round to nearest whole number 
        -SELECT CEIL(AVG(<column>)) FROM <table>;
    FLOOR 
        -
    ROUND
        -round number to nearest whole number or add decimals
        -ROUND(<number_to_round>, <number_of_decimals_places>)
    COUNT 
        -counts number of entries in a table for the specified column
        ***Distinct and Group By can do the same thing 
        -BUT occur in different places in the query 
        -Soo you can add COUNT,MIN, MAX, AVG to GROUP BY
    DISTINCT
        -SELECT DISTINCT(<column>) FROM <table>;
    GROUP BY    
        -SELECT <column> FROM <table> GROUP BY <column>
        -SELECT major_id, COUNT(*) FROM students GROUP BY major_id;
        -SELECT major_id, MIN(gpa), MAX(gpa) FROM students GROUP BY major_id;
            -returns 2 columns 
                -major_id with a count of how many in each 
        -***********************************************************
        -When using GROUP BY, any columns in the SELECT area must be 
            included in the GROUP BY area. Other columns must be used 
            with any of the aggregate functions (MAX, AVG, COUNT, etc). 
        ************************************************************
    HAVING:
        -SELECT <column> FROM <table> GROUP BY <column> HAVING <condition>;
        -*******
        - condition must be an aggregate function with a test. An example to might be to use HAVING COUNT(*) > 0
    AS 
        - Rename the MIN(gpa) column like this: MIN(gpa) AS min_gpa
        -SELECT major_id, MIN(gpa) AS min_gpa, MAX(gpa) FROM students GROUP BY major_id HAVING MAX(gpa) = 4.0;
        ******THE BELOW WAS INTERESTING BEWARE************
        SELECT major_id, COUNT(major_id)  AS number_of_students FROM students GROUP BY major_id;
            **got a different count from the below
            SELECT major_id, COUNT(*) AS number_of_students FROM students GROUP BY major_id; 
        ***The count of the NULL values was 0 in the first and 8 in the second
            -sooo the top query didn't count the null values 
        SELECT s.major_id FROM students AS s FULL JOIN majors AS m ON s.major_id = m.major_id;
    USING 
        -shortcut keyword to join tables if the foreign key column has the same name in both tables
        -will also only return 1 of the columns that are being used to JOIN the tables 
        -SELECT * FROM <table_1> FULL JOIN <table_2> USING(<column>);
        -SELECT * FROM <table_1> FULL JOIN <table_2> USING(<column>) FULL JOIN <table_3> USING(<column>).

Selecting Specific Columns from a Join . . . 
SELECT major FROM students INNER JOIN majors ON students.major_id = majors.major_id;
    -This prints/selects only the major row that is a combination of students and major on an INNNER JOIN 
        